<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8" />
  <title>M√¥ ph·ªèng CA ‚Äì Tr·∫°m Thu Ph√≠ v2.1.5 (Fan-out + Lane Commitment)</title>
  <style>
    body { font-family: Arial, sans-serif; background:#111; color:#eee; margin:20px; }
    canvas { background:#222; display:block; margin:10px 0; }
    .stats { margin-top:10px; font-size:14px; }
    .notes { background:#1c1c1c; padding:12px; border-left:4px solid #4dd0e1; margin-top:15px; font-size:14px; }
    .controls { display:flex; gap:20px; flex-wrap:wrap; margin:10px 0; }
    .controls div { background:#1b1b1b; padding:8px 12px; border-radius:6px; font-size:13px; }
    label { display:block; }
  </style>
</head>
<body>

<h2>M√¥ ph·ªèng tr·∫°m thu ph√≠ ‚Äì v2.1.5</h2>
<p>Phi√™n b·∫£n n√†y m·ªü r·ªông m√¥ h√¨nh b·∫±ng <b>fan-out (t√°ch l√†n)</b> v√† <b>lane commitment</b> tr∆∞·ªõc booth. Ch∆∞a √°p d·ª•ng fan-in.</p>

<canvas id="sim" width="900" height="360"></canvas>

<div class="controls">
  <div><label>Œª (l∆∞u l∆∞·ª£ng): <span id="lval"></span></label><input type="range" id="lambda" min="0.1" max="0.9" step="0.05" value="0.6"></div>
  <div><label>a (gia t·ªëc): <span id="aval"></span></label><input type="range" id="acc" min="0.1" max="1" step="0.1" value="0.9"></div>
  <div><label>Œº (service time): <span id="muval"></span></label><input type="range" id="mu" min="5" max="30" step="1" value="15"></div>
  <div>
    <label>Ch·∫ø ƒë·ªô T<sub>s</sub></label>
    <label><input type="radio" name="ts" value="fixed" checked> C·ªë ƒë·ªãnh</label>
    <label><input type="radio" name="ts" value="exp"> Ph√¢n ph·ªëi m≈©</label>
  </div>
</div>

<div class="stats">
  <div>‚è±Ô∏è Th·ªùi gian: <span id="time">0</span> s</div>
  <div>üöó Xe qua tr·∫°m: <span id="passed">0</span></div>
</div>

<div class="notes">
<b>Logic ch√≠nh:</b><br>
‚Äì L = 3 l√†n ban ƒë·∫ßu, B = 6 booth lanes (m·ªói l√†n t√°ch th√†nh 2).<br>
‚Äì Fan-out ch·ªâ ƒë∆∞·ª£c ph√©p trong m·ªôt v√πng gi·ªõi h·∫°n.<br>
‚Äì Sau ƒë√≥ xe b·ªã kh√≥a l√†n (lane commitment) tr∆∞·ªõc khi v√†o booth.<br>
‚Äì M·ªói booth x·ª≠ l√Ω song song, ch∆∞a c√≥ nh·∫≠p l√†n ph√≠a sau.
</div>

<script>
// ===== Tham s·ªë h√¨nh h·ªçc =====
const CELL = 10;
const L = 3;              // s·ªë l√†n ban ƒë·∫ßu
const B = 6;              // s·ªë booth lanes = 2L
const COLS = 90;
const BOOTH_X = 55;
const DIV_START = 30;     // b·∫Øt ƒë·∫ßu fan-out
const LOCK_START = 45;    // b·∫Øt ƒë·∫ßu kh√≥a l√†n
const DIV_END = 50;       // k·∫øt th√∫c fan-out (tr∆∞·ªõc booth)

// ===== Tham s·ªë m√¥ ph·ªèng =====
let lambda = 0.6;
let a = 0.9;
let mu = 15;
let serviceMode = 'fixed'; // fixed | exp

// ===== Tr·∫°ng th√°i =====
let grid = Array.from({ length: B }, () => Array(COLS).fill(null));
let simTime = 0;
let passedCars = 0;

function newCar(type, originLane) {
  return {
    type,
    originLane,
    inService: false,
    service: 0,
    servedOnce: false
  };
}

// ===== Arrival =====
function spawn() {
  if (Math.random() < lambda) {
    const lane = Math.floor(Math.random() * L);
    const boothLane = 2 * lane; // booth m·∫∑c ƒë·ªãnh
    if (!grid[boothLane][0]) {
      grid[boothLane][0] = newCar(Math.random() < 0.6 ? 'ETC' : 'MANUAL', lane);
    }
  }
}

// ===== Fan-out decision (ƒë√£ s·ª≠a l·ªói return) =====
function fanOutDecision(i, x, car) {
  // ch·ªâ cho ph√©p ƒë·ªïi l√†n trong v√πng fan-out v√† TR∆Ø·ªöC ƒëo·∫°n kh√≥a l√†n
  if (x < DIV_START || x >= LOCK_START) return i;

  const b1 = 2 * car.originLane;
  const b2 = b1 + 1;
  const other = (i === b1) ? b2 : b1;

  // rule ƒë∆°n gi·∫£n: n·∫øu booth hi·ªán t·∫°i ph√≠a tr∆∞·ªõc b·ªã chi·∫øm
  // v√† booth c√≤n l·∫°i tr·ªëng t·∫°i c√πng v·ªã tr√≠ x -> ƒë·ªïi l√†n
  if (!grid[other][x] && grid[i][x + 1]) {
    return other;
  }
  return i;
}

// ===== Update =====
function step() {
  simTime++;
  spawn();

  for (let i = 0; i < B; i++) {
    for (let x = COLS - 1; x >= 0; x--) {
      const car = grid[i][x];
      if (!car) continue;

      // ===== Thu ph√≠ xe ti·ªÅn m·∫∑t =====
      if (car.type === 'MANUAL') {
        if (x === BOOTH_X && !car.inService && !car.servedOnce) {
          car.inService = true;
          car.service = serviceMode === 'fixed'
            ? mu
            : Math.ceil(-mu * Math.log(1 - Math.random()));
        }
        if (car.inService) {
          car.service--;
          if (car.service <= 0) {
            car.inService = false;
            car.servedOnce = true;
          }
          continue;
        }
      }

      // ===== Fan-out decision =====
      const targetLane = fanOutDecision(i, x, car);
      if (targetLane !== i) {
        grid[i][x] = null;
        grid[targetLane][x] = car;
        continue;
      }

      // ===== Di chuy·ªÉn ti·∫øn (v_max = 1) =====
      const nextX = x + 1;
      if (nextX < COLS && !grid[i][nextX]) {
        if (Math.random() < a) {
          grid[i][x] = null;
          if (nextX === COLS - 1) passedCars++;
          else grid[i][nextX] = car;
        }
      }
    }
  }
}

// ===== Draw =====
const ctx = document.getElementById('sim').getContext('2d');
function draw() {
  ctx.clearRect(0, 0, 900, 360);

  // booth line
  ctx.strokeStyle = 'red';
  ctx.beginPath();
  ctx.moveTo(BOOTH_X * CELL, 0);
  ctx.lineTo(BOOTH_X * CELL, B * CELL);
  ctx.stroke();

  // fan-out zone
  ctx.fillStyle = 'rgba(255,255,255,0.05)';
  ctx.fillRect(DIV_START * CELL, 0, (LOCK_START - DIV_START) * CELL, B * CELL);

  // lane commitment zone
  ctx.fillStyle = 'rgba(255,0,0,0.05)';
  ctx.fillRect(LOCK_START * CELL, 0, (DIV_END - LOCK_START) * CELL, B * CELL);

  for (let i = 0; i < B; i++) {
    for (let x = 0; x < COLS; x++) {
      const car = grid[i][x];
      if (!car) continue;
      ctx.fillStyle = car.type === 'ETC' ? '#4dd0e1' : '#ffca28';
      ctx.fillRect(x * CELL, i * CELL, CELL - 1, CELL - 1);
    }
  }
}

function updateUI() {
  time.textContent = simTime;
  passed.textContent = passedCars;
  lval.textContent = lambda;
  aval.textContent = a;
  muval.textContent = mu;
}

// ===== UI bindings =====
document.getElementById('lambda').oninput = e => lambda = +e.target.value;
document.getElementById('acc').oninput = e => a = +e.target.value;
document.getElementById('mu').oninput = e => mu = +e.target.value;
document.getElementsByName('ts').forEach(r => r.onchange = e => serviceMode = e.target.value);

setInterval(() => {
  step();
  draw();
  updateUI();
}, 200);
</script>

</body>
</html>
